<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Test on Блог Анатолия Гладкого</title>
    <link>https://www.agladky.ru/tags/test/index.xml</link>
    <description>Recent content in Test on Блог Анатолия Гладкого</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-RU</language>
    <atom:link href="https://www.agladky.ru/tags/test/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Как тестировать абстрактные классы</title>
      <link>https://www.agladky.ru/blog/how-to-test-abstract-classes/</link>
      <pubDate>Sat, 05 Sep 2015 13:10:07 +0300</pubDate>
      
      <guid>https://www.agladky.ru/blog/how-to-test-abstract-classes/</guid>
      <description>

&lt;p&gt;Абстрактные классы сложно тестировать. Рассмотрим ситуации применения абстрактных классов и последующего рефакторинга для проведения юнит тестирования.&lt;/p&gt;

&lt;h3 id=&#34;выделить-реальный-интерфейс&#34;&gt;Выделить реальный интерфейс&lt;/h3&gt;

&lt;p&gt;Существует специализированный абстрактный класс, но все клиенты используют его конкретные реализации через единый публичный интерфейс:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/-Q17gK6ru1Ao/Vh6PH2fppfI/AAAAAAAAAiM/zeQXaGI1myw/s640-Ic42/Situation1_before_my.png&#34; alt=&#34;&#34; title=&#34;Cитуация 1 до&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Классы-потомки реализуют интерфейс, определенный абстрактными методами класса. Для повышения тестируемости этот интерфейс выделяется. Абстрактный класс превращается в конкретный и в его конструктор передается объект классов-потомков, реализующих выделенный интерфейс.&lt;/p&gt;

&lt;p&gt;Применяется шаблон проектирования &lt;a href=&#34;https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)&#34;&gt;стратегия&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/-jgWvDdeAlao/Vh6PH2OF0CI/AAAAAAAAAiA/5EoJ4lRRonE/s640-Ic42/Situation1_after_my.png&#34; alt=&#34;&#34; title=&#34;Cитуация 1 после&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Бывший абстрактный класс теперь тестируется используя мок-объект нового интерфейса. Все просто.&lt;/p&gt;

&lt;h3 id=&#34;выделить-хелпер&#34;&gt;Выделить хелпер&lt;/h3&gt;

&lt;p&gt;Абстрактный класс используется для исключения повторений в наследуемых классах. Классы-потомки используются напрямую.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/-HxhHgIWdCds/Vh6PINmZ0NI/AAAAAAAAAiI/20-toWjmQHE/s640-Ic42/Situation2_before_my.png&#34; alt=&#34;&#34; title=&#34;Cитуация 2 до&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Абстрактный класс работает как хелпер (helper).&lt;/p&gt;

&lt;p&gt;Чтобы повысить тестируемость, не повторяющийся код переносится в существующие классы. Оставшиеся методы выделяются в хелпер и передаются через интерфейс в конструкторы конкретных классов.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/-9oAhCjCnrFc/Vh6PH7B1ffI/AAAAAAAAAiE/q06QyuW6SAc/s640-Ic42/Situation2_after_my.png&#34; alt=&#34;&#34; title=&#34;Cитуация 2 после&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Базовый класс удаляется. Этот способ снова приводит дизайн к конкретным классам, которые просто и легко тестировать.&lt;/p&gt;

&lt;h3 id=&#34;совет&#34;&gt;Совет&lt;/h3&gt;

&lt;p&gt;Предпочитайте сложную сеть простых объектов над простой сетью сложных. Ключ к трестируемому коду — маленькие строительные блоки и слабая связанность.&lt;/p&gt;

&lt;h3 id=&#34;комбинация-ситуаций&#34;&gt;Комбинация ситуаций&lt;/h3&gt;

&lt;p&gt;Встречаются ситуации когда базовый класс содержит как публичный интерфейс, так и защищенные методы-помощники. В этом случае вспомогательные методы отправляются в один класс (ситуация 2), а для наследников реализуется шаблон стратегия (ситуация 1).&lt;/p&gt;

&lt;p&gt;Когда в абстрактном классе часть методов виртуальные, а часть реализованные, еще возможно провести рефакторинг. Например, превратить классы наследники в стратегию. Но, такой случай — хороший индикатор, что ответственности требуют пересмотра.&lt;/p&gt;

&lt;p&gt;Пишите в комментариях примеры когда сложно обойтись без абстрактного класса.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>