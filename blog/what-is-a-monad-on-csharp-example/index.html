<!DOCTYPE html>
<html lang="ru-RU">

<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:description" content="Краткий перевод статьи Эрика Липперта о реализации монад в .net на примере c#" />
<meta property="og:type" content="article" />
<meta property="og:site_name" content="Блог Анатолия Гладкого" />

  


  <base href="http://www.agladky.ru/">
  <title>
    
    
       Что такое монады на примере C# 
    
  </title>
  <link rel="canonical" href="http://www.agladky.ru/blog/what-is-a-monad-on-csharp-example/">
  

<script type="text/javascript">
  var baseURL = 'http:\/\/www.agladky.ru\/';
  var host = baseURL.substring(0, baseURL.length - 1).replace(/\//g, '');
  if ((host === window.location.host) && (window.location.protocol !== 'https:')) {
    window.location.protocol = 'https:';
  }
</script>



<script src="http://www.agladky.ru/js/likely.js"></script>





<link rel="stylesheet" href="http://www.agladky.ru/css/reset.css">
<link rel="stylesheet" href="http://www.agladky.ru/css/pygments.css">
<link rel="stylesheet" href="http://www.agladky.ru/css/main.css">
<link rel="stylesheet" href="http://www.agladky.ru/css/likely.css">






<link rel="shortcut icon"

  href="http://www.agladky.ru/img/leaf.ico"

>



</head>


<body lang="ru">

<section class="header">
  <div class="container">
    <div class="content">
      
        <a href="http://www.agladky.ru/blog">
          <span class="name">Блог Анатолия Гладкого</span>
        </a>
      
      
    </div>
  </div>
</section>


<section class="main post non-narrow zero-top-spacing">
  <div class="container">
    <div class="content">
      <article>
        <div class="title-container">
          <span class="page-heading">
  
    Что такое монады на примере C#
  
</span>

        </div>
        <div class="markdown">
          

<p>Конспект — вольный перевод одного из лучших циклов статей о монадах. Эрик Липперт, на протяжении 13 глав, отвечает на вопрос:</p>

<blockquote>
<p>Я C# разработчик без опыта в «функциональном программировании». Что такое «монада» и как можно её использовать для себя?</p>
</blockquote>

<p>Оригинальный цикл статей доступна по <a href="http://ericlippert.com/category/monads/">тегу monads</a>.</p>

<h3 id="часть-первая">Часть первая</h3>

<p>Монада в функциональном программировании — абстракция линейной цепочки связанных вычислений. Её основное назначение — инкапсуляция функций с побочным эффектом от чистых функций, а точнее их выполнений от вычислений. (Определение из википедии).</p>

<p>«Шаблон монады» это еще один шаблон для типов. Как, например, одиночка (синглтон).</p>

<h3 id="часть-вторая">Часть вторая</h3>

<ul>
<li><code>Nullable&lt;T&gt;</code> — представляет объект типа T, который может быть <code>null</code> (в дальнейшем, подразумевается что <code>Nullable&lt;T&gt;</code> может работать с любым типом данных).</li>
<li><code>Func&lt;T&gt;</code> — представляет объект типа T, который будет вычислен отложено (в дальнейшем, для бльшей ясности, будет использоваться делегат <code>delegate T OnDemand&lt;T&gt;();</code>).</li>
<li><code>Lazy&lt;T&gt;</code> — представляет объект типа T, который будет вычислен отложено в первый раз, а после, закеширован.</li>
<li><code>Task&lt;T&gt;</code> — представляет объект типа T, который будет вычислен асинхронно и будет доступен в будущем, если уже не вычислен.</li>
<li><code>IEnumerable&lt;T&gt;</code> — представляет упорядоченную, доступную только для чтения последовательность от нуля и более элементов типа T.</li>
</ul>

<h3 id="часть-третья">Часть третья</h3>

<p>Первое требование для монад: «если <code>M&lt;T&gt;</code> это тип-монада, тогда должен быть простой путь по превращению любого значение типа <code>T</code> в значение типа <code>M&lt;T&gt;</code>». Например:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleNullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleOnDemand</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">item</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleSequence</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">yield</span> <span class="k">return</span> <span class="n">item</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>

<p>Кажется, что второе требование просто сформулировать: «из монады <code>M&lt;T&gt;</code>можно получить значение типа <code>T</code>». Но не все так однозначно. Начнем с очень специфичного вопроса. Можно легко прибавить единицу к целочисленному типу, но как «прибавить единицу» к типу-монаде обернутого вокруг целочисленного типа?</p>

<p>Для <code>Nullable&lt;T&gt;</code>:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">CreateSimpleNullable</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>  
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div>

<p>Т.е. можно развернуть, произвести операцию и завернуть? Не совсем, если проделать ту же операцию для <code>OnDemand&lt;T&gt;()</code>, который обернут вокруг <code>DateTime.Now.Seconds</code>, то получится статическое значение. Поэтому проделанную операцию вместе с разворачиванием необходимо завернуть в функцию, как показано здесь:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">OnDemand</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">onDemand</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">onDemand</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>

<p>Т.е. тип монады по требованию, не просто оболочка вокруг значения. Она производит объект, структура которого кодирует последовательность операций, которые будут происходить по требованию. Это одна из особенностей, которая делает монады полезными. Но об этом позже.</p>

<p>Для <code>Lazy&lt;T&gt;</code>:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">lazy</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">lazy</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<p>Для <code>Task&lt;T&gt;</code>:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">async</span> <span class="k">static</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>И, наконец, для <code>IEnumerable&lt;T&gt;</code>:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">foreach</span><span class="p">(</span><span class="kt">int</span> <span class="n">unwrapped</span> <span class="k">in</span> <span class="n">sequence</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Таким образом, одно из полезных правил для шаблона монад — добавление единицы к завернутому целочисленному типу производит другой завернутый целочисленный тип, с сохранением всех особенностей.</p>

<h3 id="часть-четвертая">Часть четвертая</h3>

<p>Напишем метод, который позволит делать оболочку над любыми <code>Nullable&lt;T&gt;</code> функциями, а не только операцией по добавлению единицы:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
  <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">T</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div>

<p>Теперь метод <code>AddOne(...)</code> будет выглядеть так:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">ApplyFunction</span><span class="p">(</span><span class="n">nullable</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Но, допустим мы хотим функцию которая принимает тип <code>int</code> и возвращает <code>double</code>. Например, поделить 2 целых числа и получить результат типа <code>double</code>. Для этого, перепишем метод <code>ApplyFunction</code> в следующий вид:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">R</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div>

<p>Для остальных типов, можно сделать по аналогии. По сути, получился способ превращения типов из <code>A</code> в <code>R</code> в монадические типы из <code>М&lt;А&gt;</code> в <code>М&lt;R&gt;</code> такие, что сохраняется действие функции и значения предоставляемые в монадическом («расширенном») типе.</p>

<h3 id="часть-пятая">Часть пятая</h3>

<p>Ранее было указано, что можно взять любую функцию с одним параметром и любым не пустым возвращаемым типом и применить эту функцию к монаде с возвращаемым типом <code>M&lt;R&gt;</code>. Любой возвращаемый тип, так? Предположим, что есть функция с одним параметром:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">SafeLog</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="n">Math</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div>

<p>Обычная функция с одним параметром. Значит, ее можно применить к <code>Nullable&lt;int&gt;</code> и получить обратно&hellip; <code>Nullable&lt;Nullable&lt;double&gt;&gt;</code>! Это неправильно.</p>

<p>Создадим новую версию <code>ApplyFunction</code>, которая избегает описанной проблемы:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div>

<p>Просто, не так ли? Создадим функции для остальных операторов:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">onDemand</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">onDemand</span><span class="p">();</span>
    <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">result</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">lazy</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">Lazy</span><span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">lazy</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Task</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
  <span class="n">Task</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">await</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">sequence</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">foreach</span><span class="p">(</span><span class="n">A</span> <span class="n">unwrapped</span> <span class="k">in</span> <span class="n">sequence</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">R</span> <span class="n">r</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>В итоге, для «шаблона монады» имеются 3 правила:</p>

<ol>
<li><p>Всегда существует возможность преобразовать тип <code>T</code> в тип <code>M&lt;T&gt;</code>.</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
</code></pre></div></li>

<li><p>Если существует функция преобразующая <code>A</code> в <code>R</code>, тогда можно применить эту функцию к экземпляру <code>M&lt;A&gt;</code> и получить экземпляр <code>M&lt;R&gt;</code>.</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">wrapped</span><span class="p">,</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
</code></pre></div></li>

<li><p>Если существует функция преобразующая <code>A</code> в <code>M&lt;R&gt;</code>, тогда можно применить эту функцию к экземпляру <code>M&lt;A&gt;</code> и получить экземпляр <code>M&lt;R&gt;</code>.</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">wrapped</span><span class="p">,</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
</code></pre></div></li>
</ol>

<p>Но, правило 2 является частным случаем правила 3. Его можно представить в как комбинацию 1 и 3 правила:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">wrapped</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
    <span class="n">wrapped</span><span class="p">,</span>
    <span class="p">(</span><span class="n">A</span> <span class="n">unwrapped</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>

<p>Остается всего два правила. Они являются полными правилами «шаблона монады»? В принципе, да.</p>

<h3 id="часть-шестая">Часть шестая</h3>

<p>Необходимо, чтобы операции упаковки и распаковки сохраняли значение.</p>

<p>Пусть имеются 2 метода:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">monad</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span> <span class="p">{...}</span>
</code></pre></div>

<p>Тогда, результат следующего выражения:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">someMonadValue</span><span class="p">,</span> <span class="n">CreateSimpleM</span><span class="p">)</span>
</code></pre></div>

<p>по значению идентичен <code>someMonadValue</code>, а результат следующего выражения:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">CreateSimpleM</span><span class="p">(</span><span class="n">someValue</span><span class="p">),</span> <span class="n">someFunction</span><span class="p">)</span>
</code></pre></div>

<p>по значению идентичен:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="n">someFunction</span><span class="p">(</span><span class="n">someValue</span><span class="p">)</span>
</code></pre></div>

<h3 id="часть-седьмая">Часть седьмая</h3>

<p>Допустим, имеются 2 функции:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;&gt;</span> <span class="n">log</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span>
    <span class="p">?</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="n">Math</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">:</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;();</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;&gt;</span> <span class="n">toDecimal</span> <span class="p">=</span> <span class="n">y</span> <span class="p">=&gt;</span> <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">&lt;</span> <span class="kt">decimal</span><span class="p">.</span><span class="n">MaxValue</span>
    <span class="p">?</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;((</span><span class="kt">decimal</span><span class="p">)</span><span class="n">y</span><span class="p">)</span>
    <span class="p">:</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;();</span>
</code></pre></div>

<p>Тогда, с помощью определенного ранее метода <code>ApplySpecialFunction</code> можно написать следующий метод-помощник:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">ComposeSpecial</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">&gt;(</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">&gt;&gt;</span> <span class="n">f</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>который позволяет объединить определенные выше функции в одну:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;&gt;</span> <span class="n">both</span> <span class="p">=</span> <span class="n">ComposeSpecial</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">toDecimal</span><span class="p">);</span>
</code></pre></div>

<p>Отсюда следует последнее правило — метод <code>ApplySpecialFunction</code> должен гарантировать работу композиции. Пример:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">&gt;&gt;</span> <span class="n">f</span> <span class="p">=</span> <span class="n">whatever</span><span class="p">;</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">g</span> <span class="p">=</span> <span class="n">whatever</span><span class="p">;</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">X</span><span class="p">&gt;</span> <span class="n">mx</span> <span class="p">=</span> <span class="n">whatever</span><span class="p">;</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">&gt;</span> <span class="n">my</span> <span class="p">=</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;</span> <span class="n">mz1</span> <span class="p">=</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">my</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">h</span> <span class="p">=</span> <span class="n">ComposeSpecial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;</span> <span class="n">mz2</span> <span class="p">=</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</code></pre></div>

<p>Значения <code>mz1</code> и <code>mz2</code> должны быть одинаковыми.</p>

<p>Наконец, можно полностью описать «шаблон монады» в C#:</p>

<p>Монада это обобщенный тип <code>M&lt;T&gt;</code>, такой что:</p>

<ul>
<li><p>Для нее существует конструирующий механизм, который принимает на вход переменную типа <code>T</code> и возвращает <code>M&lt;T&gt;</code>:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div></li>

<li><p>Если существует способ преобразования значения типа <code>A</code> в <code>M&lt;R&gt;</code>, то можно применить эту функцию к экземпляру <code>M&lt;A&gt;</code> и получить экземпляр <code>M&lt;R&gt;</code>:</p>
<div class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span></span><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">monad</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
</code></pre></div></li>
</ul>

<p>Оба этих метода должны подчинятся следующим законам:</p>

<ul>
<li>Применение функции создающую простую монаду (правило-метод 1) к конкретному экземпляру монады должно приводить к логически идентичному экземпляру монады.</li>
<li>Применение функции к результату функции создающей простую монаду из определенного значения и применение этой функции к определенному значению напрямую должно приводить к логически идентичным экземплярам монад.</li>
<li>Результат применения к значению первой функции второй функции и результат применения первоначального значения к функции-композиции первых двух функций должен приводить к двум логически идентичным экземплярам монад.</li>
</ul>

<h3 id="часть-восьмая">Часть восьмая</h3>

<p>Традиционное имя для функции <code>CreateSimple</code> — <code>unit</code>. В Haskell — <code>return</code>.</p>

<p>Традиционное имя для функции <code>ApplySpecialFunction</code> — <code>bind</code>. В Haskell она является встроенной функцией, для того чтобы применить функцию <code>f</code> на экземпляр монады <code>m</code> необходимо написать <code>m &gt;&gt;= f</code>.</p>

<p>Фактически, функция привязки берет неизменный рабочий процесс и операцию над ним и возвращает новый рабочий процесс.</p>

<p>Мой конспект на этом оканчивается. В последующих частях серии рассматривается практическое применение монад в коде.</p>

<ul>
<li><a href="http://ericlippert.com/2013/03/21/monads-part-nine/">Часть 9</a>. О простых монадах «присоединяющих дополнительные данные к значению».</li>
<li><a href="http://ericlippert.com/2013/03/25/monads-part-ten/">Часть 10</a>. О запросах и LINQ на примере <code>SelectMany</code>.</li>
<li><a href="http://ericlippert.com/2013/03/28/monads-part-eleven/">Часть 11</a>. Дополнения к предыдущей главе. Аддитивная монада.</li>
<li><a href="http://ericlippert.com/2013/04/02/monads-part-twelve/">Часть 12</a>. Продолжение про запросы и <code>SelectMany</code>.</li>
<li><a href="http://ericlippert.com/2013/04/03/monads-part-thirteen/">Часть 13</a>. О <code>Task</code> монадах.</li>
</ul>

        </div>
        <div class="article-links">
  <div class="likely">
    <div class="twitter">Твитнуть</div>
    <div class="facebook">Поделиться</div>
    <div class="gplus">Плюсануть</div>
    <div class="vkontakte">Поделиться</div>
    <div class="telegram">Отправить</div>
  </div>
</div>

        <div class="meta">
  
  <span class="date" title="27 января 2016, 13:10 MSK">
    27 января 2016
  </span>

   <a class="tag" href="tags/.net">.net</a>   <a class="tag" href="tags/functional">functional</a>   

</div>

      </article>

      <div class="post-navigation">
        
          <div class="post-prev-next">
            <a href="http://www.agladky.ru/blog/differences-comparison-operators-in-javascript/">← Различия операторов == и === в JavaScript</a>  
          </div>
        
        
          <div class="post-prev-next">
            <a href="http://www.agladky.ru/blog/my-first-python-script/">Первый скрипт на Python →</a>
          </div>
        
      </div>

      <br />
      <div class="disqus">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'agladky';
    var disqus_identifier = 'http:\/\/www.agladky.ru\/blog\/what-is-a-monad-on-csharp-example\/';
    var disqus_title = 'Что такое монады на примере C#';
    var disqus_url = 'http:\/\/www.agladky.ru\/blog\/what-is-a-monad-on-csharp-example\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
  </div>
</section>

<section class="footer">
<div class="container">
  <div class="content">
    <span>© Анатолий Гладкий, 2016 </span><a class="rss" href="http://www.agladky.ru/index.xml">РСС</a>
    <br />
    <span>Эл. почта: <a class="" href="mailto:me@agladky.ru">me@agladky.ru</a></span>
  </div>
</div>
</section>



<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-75808442-1");
    pageTracker._trackPageview();
  } catch (err) {}
</script>



</body>

</html>

